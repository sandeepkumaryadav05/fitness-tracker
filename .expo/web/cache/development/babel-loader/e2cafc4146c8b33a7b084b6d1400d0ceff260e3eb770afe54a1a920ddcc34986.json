{"ast":null,"code":"\"use strict\";\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"navigation\"];\nimport { getHeaderTitle, Header, SafeAreaProviderCompat, Screen, useFrameSize } from '@react-navigation/elements';\nimport { DrawerActions, StackActions, useLocale, useTheme } from '@react-navigation/native';\nimport * as React from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport { Drawer } from 'react-native-drawer-layout';\nimport useLatestCallback from 'use-latest-callback';\nimport { addCancelListener } from '../utils/addCancelListener';\nimport { DrawerPositionContext } from \"../utils/DrawerPositionContext.js\";\nimport { DrawerStatusContext } from \"../utils/DrawerStatusContext.js\";\nimport { getDrawerStatusFromState } from \"../utils/getDrawerStatusFromState.js\";\nimport { DrawerContent } from \"./DrawerContent.js\";\nimport { DrawerToggleButton } from \"./DrawerToggleButton.js\";\nimport { MaybeScreen, MaybeScreenContainer } from \"./ScreenFallback.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DRAWER_BORDER_RADIUS = 16;\nconst renderDrawerContentDefault = props => _jsx(DrawerContent, Object.assign({}, props));\nfunction DrawerViewBase({\n  state,\n  navigation,\n  descriptors,\n  defaultStatus,\n  drawerContent = renderDrawerContentDefault,\n  detachInactiveScreens = Platform.OS === 'web' || Platform.OS === 'android' || Platform.OS === 'ios'\n}) {\n  const {\n    direction\n  } = useLocale();\n  const focusedRouteKey = state.routes[state.index].key;\n  const {\n    drawerHideStatusBarOnOpen,\n    drawerPosition = direction === 'rtl' ? 'right' : 'left',\n    drawerStatusBarAnimation,\n    drawerStyle,\n    drawerType = Platform.select({\n      ios: 'slide',\n      default: 'front'\n    }),\n    configureGestureHandler,\n    keyboardDismissMode,\n    overlayColor = 'rgba(0, 0, 0, 0.5)',\n    swipeEdgeWidth,\n    swipeEnabled = Platform.OS !== 'web' && Platform.OS !== 'windows' && Platform.OS !== 'macos',\n    swipeMinDistance,\n    overlayAccessibilityLabel\n  } = descriptors[focusedRouteKey].options;\n  const [loaded, setLoaded] = React.useState([focusedRouteKey]);\n  if (!loaded.includes(focusedRouteKey)) {\n    setLoaded([...loaded, focusedRouteKey]);\n  }\n  const previousRouteKeyRef = React.useRef(focusedRouteKey);\n  React.useEffect(() => {\n    const previousRouteKey = previousRouteKeyRef.current;\n    if (previousRouteKey !== focusedRouteKey && descriptors[previousRouteKey]?.options.popToTopOnBlur) {\n      const prevRoute = state.routes.find(route => route.key === previousRouteKey);\n      if (prevRoute?.state?.type === 'stack' && prevRoute.state.key) {\n        navigation.dispatch(Object.assign({}, StackActions.popToTop(), {\n          target: prevRoute.state.key\n        }));\n      }\n    }\n    previousRouteKeyRef.current = focusedRouteKey;\n  }, [descriptors, focusedRouteKey, navigation, state.routes]);\n  const dimensions = useFrameSize(size => size, true);\n  const {\n    colors\n  } = useTheme();\n  const drawerStatus = getDrawerStatusFromState(state);\n  const handleDrawerOpen = useLatestCallback(() => {\n    navigation.dispatch(Object.assign({}, DrawerActions.openDrawer(), {\n      target: state.key\n    }));\n  });\n  const handleDrawerClose = useLatestCallback(() => {\n    navigation.dispatch(Object.assign({}, DrawerActions.closeDrawer(), {\n      target: state.key\n    }));\n  });\n  const handleGestureStart = useLatestCallback(() => {\n    navigation.emit({\n      type: 'gestureStart',\n      target: state.key\n    });\n  });\n  const handleGestureEnd = useLatestCallback(() => {\n    navigation.emit({\n      type: 'gestureEnd',\n      target: state.key\n    });\n  });\n  const handleGestureCancel = useLatestCallback(() => {\n    navigation.emit({\n      type: 'gestureCancel',\n      target: state.key\n    });\n  });\n  const handleTransitionStart = useLatestCallback(closing => {\n    navigation.emit({\n      type: 'transitionStart',\n      data: {\n        closing\n      },\n      target: state.key\n    });\n  });\n  const handleTransitionEnd = useLatestCallback(closing => {\n    navigation.emit({\n      type: 'transitionEnd',\n      data: {\n        closing\n      },\n      target: state.key\n    });\n  });\n  React.useEffect(() => {\n    if (drawerStatus === defaultStatus || drawerType === 'permanent') {\n      return;\n    }\n    const handleHardwareBack = () => {\n      if (!navigation.isFocused()) {\n        return false;\n      }\n      if (defaultStatus === 'open') {\n        handleDrawerOpen();\n      } else {\n        handleDrawerClose();\n      }\n      return true;\n    };\n    return addCancelListener(handleHardwareBack);\n  }, [defaultStatus, drawerStatus, drawerType, handleDrawerClose, handleDrawerOpen, navigation]);\n  const renderDrawerContent = () => {\n    return _jsx(DrawerPositionContext.Provider, {\n      value: drawerPosition,\n      children: drawerContent({\n        state: state,\n        navigation: navigation,\n        descriptors: descriptors\n      })\n    });\n  };\n  const renderSceneContent = () => {\n    return _jsx(MaybeScreenContainer, {\n      enabled: detachInactiveScreens,\n      hasTwoStates: true,\n      style: styles.content,\n      children: state.routes.map((route, index) => {\n        const descriptor = descriptors[route.key];\n        const {\n          lazy = true\n        } = descriptor.options;\n        const isFocused = state.index === index;\n        const isPreloaded = state.preloadedRouteKeys.includes(route.key);\n        if (lazy && !loaded.includes(route.key) && !isFocused && !isPreloaded) {\n          return null;\n        }\n        const {\n          freezeOnBlur,\n          header = ({\n            layout,\n            options\n          }) => _jsx(Header, Object.assign({}, options, {\n            layout: layout,\n            title: getHeaderTitle(options, route.name),\n            headerLeft: drawerPosition === 'left' && options.headerLeft == null ? props => _jsx(DrawerToggleButton, Object.assign({}, props)) : options.headerLeft,\n            headerRight: drawerPosition === 'right' && options.headerRight == null ? props => _jsx(DrawerToggleButton, Object.assign({}, props)) : options.headerRight\n          })),\n          headerShown,\n          headerStatusBarHeight,\n          headerTransparent,\n          sceneStyle\n        } = descriptor.options;\n        return _jsx(MaybeScreen, {\n          style: [StyleSheet.absoluteFill, {\n            zIndex: isFocused ? 0 : -1\n          }],\n          visible: isFocused,\n          enabled: detachInactiveScreens,\n          freezeOnBlur: freezeOnBlur,\n          shouldFreeze: !isFocused && !isPreloaded,\n          children: _jsx(Screen, {\n            focused: isFocused,\n            route: descriptor.route,\n            navigation: descriptor.navigation,\n            headerShown: headerShown,\n            headerStatusBarHeight: headerStatusBarHeight,\n            headerTransparent: headerTransparent,\n            header: header({\n              layout: dimensions,\n              route: descriptor.route,\n              navigation: descriptor.navigation,\n              options: descriptor.options\n            }),\n            style: sceneStyle,\n            children: descriptor.render()\n          })\n        }, route.key);\n      })\n    });\n  };\n  return _jsx(DrawerStatusContext.Provider, {\n    value: drawerStatus,\n    children: _jsx(Drawer, {\n      open: drawerStatus !== 'closed',\n      onOpen: handleDrawerOpen,\n      onClose: handleDrawerClose,\n      onGestureStart: handleGestureStart,\n      onGestureEnd: handleGestureEnd,\n      onGestureCancel: handleGestureCancel,\n      onTransitionStart: handleTransitionStart,\n      onTransitionEnd: handleTransitionEnd,\n      layout: dimensions,\n      direction: direction,\n      configureGestureHandler: configureGestureHandler,\n      swipeEnabled: swipeEnabled,\n      swipeEdgeWidth: swipeEdgeWidth,\n      swipeMinDistance: swipeMinDistance,\n      hideStatusBarOnOpen: drawerHideStatusBarOnOpen,\n      statusBarAnimation: drawerStatusBarAnimation,\n      keyboardDismissMode: keyboardDismissMode,\n      drawerType: drawerType,\n      overlayAccessibilityLabel: overlayAccessibilityLabel,\n      drawerPosition: drawerPosition,\n      drawerStyle: [{\n        backgroundColor: colors.card\n      }, drawerType === 'permanent' && ((Platform.OS === 'web' ? drawerPosition === 'right' : direction === 'rtl' && drawerPosition !== 'right' || direction !== 'rtl' && drawerPosition === 'right') ? {\n        borderLeftColor: colors.border,\n        borderLeftWidth: StyleSheet.hairlineWidth\n      } : {\n        borderRightColor: colors.border,\n        borderRightWidth: StyleSheet.hairlineWidth\n      }), drawerType === 'front' && (drawerPosition === 'left' ? {\n        borderTopRightRadius: DRAWER_BORDER_RADIUS,\n        borderBottomRightRadius: DRAWER_BORDER_RADIUS\n      } : {\n        borderTopLeftRadius: DRAWER_BORDER_RADIUS,\n        borderBottomLeftRadius: DRAWER_BORDER_RADIUS\n      }), drawerStyle],\n      overlayStyle: {\n        backgroundColor: overlayColor\n      },\n      renderDrawerContent: renderDrawerContent,\n      children: renderSceneContent()\n    })\n  });\n}\nexport function DrawerView(_ref) {\n  let {\n      navigation\n    } = _ref,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n  return _jsx(SafeAreaProviderCompat, {\n    children: _jsx(DrawerViewBase, Object.assign({\n      navigation: navigation\n    }, rest))\n  });\n}\nconst styles = StyleSheet.create({\n  content: {\n    flex: 1\n  }\n});","map":{"version":3,"names":["getHeaderTitle","Header","SafeAreaProviderCompat","Screen","useFrameSize","DrawerActions","StackActions","useLocale","useTheme","React","Platform","StyleSheet","Drawer","useLatestCallback","addCancelListener","DrawerPositionContext","DrawerStatusContext","getDrawerStatusFromState","DrawerContent","DrawerToggleButton","MaybeScreen","MaybeScreenContainer","jsx","_jsx","DRAWER_BORDER_RADIUS","renderDrawerContentDefault","props","Object","assign","DrawerViewBase","state","navigation","descriptors","defaultStatus","drawerContent","detachInactiveScreens","OS","direction","focusedRouteKey","routes","index","key","drawerHideStatusBarOnOpen","drawerPosition","drawerStatusBarAnimation","drawerStyle","drawerType","select","ios","default","configureGestureHandler","keyboardDismissMode","overlayColor","swipeEdgeWidth","swipeEnabled","swipeMinDistance","overlayAccessibilityLabel","options","loaded","setLoaded","useState","includes","previousRouteKeyRef","useRef","useEffect","previousRouteKey","current","popToTopOnBlur","prevRoute","find","route","type","dispatch","popToTop","target","dimensions","size","colors","drawerStatus","handleDrawerOpen","openDrawer","handleDrawerClose","closeDrawer","handleGestureStart","emit","handleGestureEnd","handleGestureCancel","handleTransitionStart","closing","data","handleTransitionEnd","handleHardwareBack","isFocused","renderDrawerContent","Provider","value","children","renderSceneContent","enabled","hasTwoStates","style","styles","content","map","descriptor","lazy","isPreloaded","preloadedRouteKeys","freezeOnBlur","header","layout","title","name","headerLeft","headerRight","headerShown","headerStatusBarHeight","headerTransparent","sceneStyle","absoluteFill","zIndex","visible","shouldFreeze","focused","render","open","onOpen","onClose","onGestureStart","onGestureEnd","onGestureCancel","onTransitionStart","onTransitionEnd","hideStatusBarOnOpen","statusBarAnimation","backgroundColor","card","borderLeftColor","border","borderLeftWidth","hairlineWidth","borderRightColor","borderRightWidth","borderTopRightRadius","borderBottomRightRadius","borderTopLeftRadius","borderBottomLeftRadius","overlayStyle","DrawerView","_ref","rest","_objectWithoutPropertiesLoose","_excluded","create","flex"],"sources":["C:\\Users\\Lenovo\\OneDrive\\Desktop\\fit-get\\fitness-tracker\\node_modules\\@react-navigation\\drawer\\src\\views\\DrawerView.tsx"],"sourcesContent":["import {\n  getHeaderTitle,\n  Header,\n  SafeAreaProviderCompat,\n  Screen,\n  useFrameSize,\n} from '@react-navigation/elements';\nimport {\n  DrawerActions,\n  type DrawerNavigationState,\n  type DrawerStatus,\n  type ParamListBase,\n  StackActions,\n  useLocale,\n  useTheme,\n} from '@react-navigation/native';\nimport * as React from 'react';\nimport { Platform, StyleSheet } from 'react-native';\nimport { Drawer } from 'react-native-drawer-layout';\nimport useLatestCallback from 'use-latest-callback';\n\nimport type {\n  DrawerContentComponentProps,\n  DrawerDescriptorMap,\n  DrawerHeaderProps,\n  DrawerNavigationConfig,\n  DrawerNavigationHelpers,\n  DrawerNavigationProp,\n} from '../types';\nimport { addCancelListener } from '../utils/addCancelListener';\nimport { DrawerPositionContext } from '../utils/DrawerPositionContext';\nimport { DrawerStatusContext } from '../utils/DrawerStatusContext';\nimport { getDrawerStatusFromState } from '../utils/getDrawerStatusFromState';\nimport { DrawerContent } from './DrawerContent';\nimport { DrawerToggleButton } from './DrawerToggleButton';\nimport { MaybeScreen, MaybeScreenContainer } from './ScreenFallback';\n\ntype Props = DrawerNavigationConfig & {\n  defaultStatus: DrawerStatus;\n  state: DrawerNavigationState<ParamListBase>;\n  navigation: DrawerNavigationHelpers;\n  descriptors: DrawerDescriptorMap;\n};\n\nconst DRAWER_BORDER_RADIUS = 16;\n\nconst renderDrawerContentDefault = (props: DrawerContentComponentProps) => (\n  <DrawerContent {...props} />\n);\n\nfunction DrawerViewBase({\n  state,\n  navigation,\n  descriptors,\n  defaultStatus,\n  drawerContent = renderDrawerContentDefault,\n  detachInactiveScreens = Platform.OS === 'web' ||\n    Platform.OS === 'android' ||\n    Platform.OS === 'ios',\n}: Props) {\n  const { direction } = useLocale();\n\n  const focusedRouteKey = state.routes[state.index].key;\n  const {\n    drawerHideStatusBarOnOpen,\n    drawerPosition = direction === 'rtl' ? 'right' : 'left',\n    drawerStatusBarAnimation,\n    drawerStyle,\n    drawerType = Platform.select({ ios: 'slide', default: 'front' }),\n    configureGestureHandler,\n    keyboardDismissMode,\n    overlayColor = 'rgba(0, 0, 0, 0.5)',\n    swipeEdgeWidth,\n    swipeEnabled = Platform.OS !== 'web' &&\n      Platform.OS !== 'windows' &&\n      Platform.OS !== 'macos',\n    swipeMinDistance,\n    overlayAccessibilityLabel,\n  } = descriptors[focusedRouteKey].options;\n\n  const [loaded, setLoaded] = React.useState([focusedRouteKey]);\n\n  if (!loaded.includes(focusedRouteKey)) {\n    setLoaded([...loaded, focusedRouteKey]);\n  }\n\n  const previousRouteKeyRef = React.useRef(focusedRouteKey);\n\n  React.useEffect(() => {\n    const previousRouteKey = previousRouteKeyRef.current;\n\n    if (\n      previousRouteKey !== focusedRouteKey &&\n      descriptors[previousRouteKey]?.options.popToTopOnBlur\n    ) {\n      const prevRoute = state.routes.find(\n        (route) => route.key === previousRouteKey\n      );\n\n      if (prevRoute?.state?.type === 'stack' && prevRoute.state.key) {\n        navigation.dispatch({\n          ...StackActions.popToTop(),\n          target: prevRoute.state.key,\n        });\n      }\n    }\n\n    previousRouteKeyRef.current = focusedRouteKey;\n  }, [descriptors, focusedRouteKey, navigation, state.routes]);\n\n  const dimensions = useFrameSize((size) => size, true);\n\n  const { colors } = useTheme();\n\n  const drawerStatus = getDrawerStatusFromState(state);\n\n  const handleDrawerOpen = useLatestCallback(() => {\n    navigation.dispatch({\n      ...DrawerActions.openDrawer(),\n      target: state.key,\n    });\n  });\n\n  const handleDrawerClose = useLatestCallback(() => {\n    navigation.dispatch({\n      ...DrawerActions.closeDrawer(),\n      target: state.key,\n    });\n  });\n\n  const handleGestureStart = useLatestCallback(() => {\n    navigation.emit({\n      type: 'gestureStart',\n      target: state.key,\n    });\n  });\n\n  const handleGestureEnd = useLatestCallback(() => {\n    navigation.emit({\n      type: 'gestureEnd',\n      target: state.key,\n    });\n  });\n\n  const handleGestureCancel = useLatestCallback(() => {\n    navigation.emit({\n      type: 'gestureCancel',\n      target: state.key,\n    });\n  });\n\n  const handleTransitionStart = useLatestCallback((closing: boolean) => {\n    navigation.emit({\n      type: 'transitionStart',\n      data: { closing },\n      target: state.key,\n    });\n  });\n\n  const handleTransitionEnd = useLatestCallback((closing: boolean) => {\n    navigation.emit({\n      type: 'transitionEnd',\n      data: { closing },\n      target: state.key,\n    });\n  });\n\n  React.useEffect(() => {\n    if (drawerStatus === defaultStatus || drawerType === 'permanent') {\n      return;\n    }\n\n    const handleHardwareBack = () => {\n      // We shouldn't handle the back button if the parent screen isn't focused\n      // This will avoid the drawer overriding event listeners from a focused screen\n      if (!navigation.isFocused()) {\n        return false;\n      }\n\n      if (defaultStatus === 'open') {\n        handleDrawerOpen();\n      } else {\n        handleDrawerClose();\n      }\n\n      return true;\n    };\n\n    // We only add the listeners when drawer opens\n    // This way we can make sure that the listener is added as late as possible\n    // This will make sure that our handler will run first when back button is pressed\n    return addCancelListener(handleHardwareBack);\n  }, [\n    defaultStatus,\n    drawerStatus,\n    drawerType,\n    handleDrawerClose,\n    handleDrawerOpen,\n    navigation,\n  ]);\n\n  const renderDrawerContent = () => {\n    return (\n      <DrawerPositionContext.Provider value={drawerPosition}>\n        {drawerContent({\n          state: state,\n          navigation: navigation,\n          descriptors: descriptors,\n        })}\n      </DrawerPositionContext.Provider>\n    );\n  };\n\n  const renderSceneContent = () => {\n    return (\n      <MaybeScreenContainer\n        enabled={detachInactiveScreens}\n        hasTwoStates\n        style={styles.content}\n      >\n        {state.routes.map((route, index) => {\n          const descriptor = descriptors[route.key];\n          const { lazy = true } = descriptor.options;\n          const isFocused = state.index === index;\n          const isPreloaded = state.preloadedRouteKeys.includes(route.key);\n\n          if (\n            lazy &&\n            !loaded.includes(route.key) &&\n            !isFocused &&\n            !isPreloaded\n          ) {\n            // Don't render a lazy screen if we've never navigated to it or it wasn't preloaded\n            return null;\n          }\n\n          const {\n            freezeOnBlur,\n            header = ({ layout, options }: DrawerHeaderProps) => (\n              <Header\n                {...options}\n                layout={layout}\n                title={getHeaderTitle(options, route.name)}\n                headerLeft={\n                  drawerPosition === 'left' && options.headerLeft == null\n                    ? (props) => <DrawerToggleButton {...props} />\n                    : options.headerLeft\n                }\n                headerRight={\n                  drawerPosition === 'right' && options.headerRight == null\n                    ? (props) => <DrawerToggleButton {...props} />\n                    : options.headerRight\n                }\n              />\n            ),\n            headerShown,\n            headerStatusBarHeight,\n            headerTransparent,\n            sceneStyle,\n          } = descriptor.options;\n\n          return (\n            <MaybeScreen\n              key={route.key}\n              style={[StyleSheet.absoluteFill, { zIndex: isFocused ? 0 : -1 }]}\n              visible={isFocused}\n              enabled={detachInactiveScreens}\n              freezeOnBlur={freezeOnBlur}\n              shouldFreeze={!isFocused && !isPreloaded}\n            >\n              <Screen\n                focused={isFocused}\n                route={descriptor.route}\n                navigation={descriptor.navigation}\n                headerShown={headerShown}\n                headerStatusBarHeight={headerStatusBarHeight}\n                headerTransparent={headerTransparent}\n                header={header({\n                  layout: dimensions,\n                  route: descriptor.route,\n                  navigation:\n                    descriptor.navigation as DrawerNavigationProp<ParamListBase>,\n                  options: descriptor.options,\n                })}\n                style={sceneStyle}\n              >\n                {descriptor.render()}\n              </Screen>\n            </MaybeScreen>\n          );\n        })}\n      </MaybeScreenContainer>\n    );\n  };\n\n  return (\n    <DrawerStatusContext.Provider value={drawerStatus}>\n      <Drawer\n        open={drawerStatus !== 'closed'}\n        onOpen={handleDrawerOpen}\n        onClose={handleDrawerClose}\n        onGestureStart={handleGestureStart}\n        onGestureEnd={handleGestureEnd}\n        onGestureCancel={handleGestureCancel}\n        onTransitionStart={handleTransitionStart}\n        onTransitionEnd={handleTransitionEnd}\n        layout={dimensions}\n        direction={direction}\n        configureGestureHandler={configureGestureHandler}\n        swipeEnabled={swipeEnabled}\n        swipeEdgeWidth={swipeEdgeWidth}\n        swipeMinDistance={swipeMinDistance}\n        hideStatusBarOnOpen={drawerHideStatusBarOnOpen}\n        statusBarAnimation={drawerStatusBarAnimation}\n        keyboardDismissMode={keyboardDismissMode}\n        drawerType={drawerType}\n        overlayAccessibilityLabel={overlayAccessibilityLabel}\n        drawerPosition={drawerPosition}\n        drawerStyle={[\n          { backgroundColor: colors.card },\n          drawerType === 'permanent' &&\n            ((\n              Platform.OS === 'web'\n                ? drawerPosition === 'right'\n                : (direction === 'rtl' && drawerPosition !== 'right') ||\n                  (direction !== 'rtl' && drawerPosition === 'right')\n            )\n              ? {\n                  borderLeftColor: colors.border,\n                  borderLeftWidth: StyleSheet.hairlineWidth,\n                }\n              : {\n                  borderRightColor: colors.border,\n                  borderRightWidth: StyleSheet.hairlineWidth,\n                }),\n\n          drawerType === 'front' &&\n            (drawerPosition === 'left'\n              ? {\n                  borderTopRightRadius: DRAWER_BORDER_RADIUS,\n                  borderBottomRightRadius: DRAWER_BORDER_RADIUS,\n                }\n              : {\n                  borderTopLeftRadius: DRAWER_BORDER_RADIUS,\n                  borderBottomLeftRadius: DRAWER_BORDER_RADIUS,\n                }),\n          drawerStyle,\n        ]}\n        overlayStyle={{ backgroundColor: overlayColor }}\n        renderDrawerContent={renderDrawerContent}\n      >\n        {renderSceneContent()}\n      </Drawer>\n    </DrawerStatusContext.Provider>\n  );\n}\n\nexport function DrawerView({ navigation, ...rest }: Props) {\n  return (\n    <SafeAreaProviderCompat>\n      <DrawerViewBase navigation={navigation} {...rest} />\n    </SafeAreaProviderCompat>\n  );\n}\n\nconst styles = StyleSheet.create({\n  content: {\n    flex: 1,\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}